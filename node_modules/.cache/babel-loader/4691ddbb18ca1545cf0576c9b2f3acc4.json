{"ast":null,"code":"// push startNode onto openList\n// while(openList is not empty) {\n//  currentNode = find lowest f in openList\n//  if currentNode is final, return the successful path\n//  push currentNode onto closedList and remove from openList\n//  foreach neighbor of currentNode {\n//      if neighbor is not in openList {\n//             save g, h, and f then save the current parent\n//             add neighbor to openList\n//      }\n//      if neighbor is in openList but the current g is better than previous g {\n//              save g and f, then save the current parent\n//      }\n//  }\nfunction heru(a, b) {\n  let d = Math.abs(a.row - a.col) + Math.abs(b.row - b.col);\n  return d;\n}\n\nconst getUnvisitedNeighbors = (grid, current) => {\n  var neighbors = [];\n  const {\n    col,\n    row\n  } = current;\n\n  if (row > 0) {\n    // console.log(grid[row - 1][col])    \n    neighbors.push(grid[row - 1][col]);\n  }\n\n  if (row < grid.length - 1) {\n    // console.log(grid[row + 1][col])\n    neighbors.push(grid[row + 1][col]);\n  }\n\n  if (col > 0) {\n    // console.log(grid[row][col - 1])\n    neighbors.push(grid[row][col - 1]);\n  }\n\n  if (col < grid[0].length - 1) {\n    // console.log(grid[row][col + 1])\n    neighbors.push(grid[row][col + 1]);\n  } // console.log(\"BEFORE FILTER\",neighbors)\n  // return neighbors.filter(neighbor => !neighbor.isVisited);\n\n\n  return neighbors;\n};\n\nconst Astar = (startNode, endNode, grid) => {\n  let openSet = []; // unvisited nodes (will contain nodes which we have to visit)\n\n  let closedSet = []; //visited nodes\n\n  let path = []; // will contain shortst path\n\n  let visitedNodes = [];\n  openSet.push(startNode);\n\n  while (openSet.length > 0) {\n    let leastIndex = 0;\n\n    for (let i = 0; i < openSet.length; i++) {\n      if (openSet[i].f < openSet[leastIndex].f) {\n        leastIndex = i;\n      }\n    }\n\n    let current = openSet[leastIndex];\n    visitedNodes.push(current);\n\n    if (current === endNode) {\n      console.log(\"PATH FOUND\");\n      let temp = current;\n      path.push(temp);\n\n      while (temp.previousNode) {\n        path.push(temp.previousNode);\n        temp = temp.previousNode;\n      } // console.log(path)\n\n\n      return {\n        path,\n        visitedNodes\n      };\n    }\n\n    openSet = openSet.filter(elt => elt !== current);\n    closedSet.push(current);\n    let neighbors = getUnvisitedNeighbors(grid, current); // console.log(\"NEIGHBOUTS\",neighbors)\n\n    for (let i = 0; i < neighbors.length; i++) {\n      let neighbor = neighbors[i];\n\n      if (!closedSet.includes(neighbor) && !neighbor.isWall) {\n        let tempG = current.g + 1;\n        let newPath = false;\n\n        if (openSet.includes(neighbor)) {\n          if (tempG < neighbor.g) {\n            neighbor.g = tempG;\n            newPath = true;\n          }\n        } else {\n          neighbor.g = tempG;\n          newPath = true;\n          openSet.push(neighbor);\n        }\n\n        if (newPath) {\n          neighbor.h = heru(neighbor, endNode);\n          neighbor.f = neighbor.g + neighbor.f;\n          neighbor.previousNode = current;\n        }\n      }\n    }\n  }\n\n  return {\n    path,\n    visitedNodes\n  };\n};\n\n_c = Astar;\nexport default Astar;\n\nvar _c;\n\n$RefreshReg$(_c, \"Astar\");","map":{"version":3,"names":["heru","a","b","d","Math","abs","row","col","getUnvisitedNeighbors","grid","current","neighbors","push","length","Astar","startNode","endNode","openSet","closedSet","path","visitedNodes","leastIndex","i","f","console","log","temp","previousNode","filter","elt","neighbor","includes","isWall","tempG","g","newPath","h"],"sources":["C:/Users/91842/Desktop/Graph-Algorithms-Visualizer-master/src/Algorithms/astar.js"],"sourcesContent":["// push startNode onto openList\n// while(openList is not empty) {\n//  currentNode = find lowest f in openList\n//  if currentNode is final, return the successful path\n//  push currentNode onto closedList and remove from openList\n//  foreach neighbor of currentNode {\n//      if neighbor is not in openList {\n//             save g, h, and f then save the current parent\n//             add neighbor to openList\n//      }\n//      if neighbor is in openList but the current g is better than previous g {\n//              save g and f, then save the current parent\n//      }\n//  }\n\n\nfunction heru(a,b){\n    let d = Math.abs(a.row-a.col) + Math.abs(b.row - b.col);\n    return d;\n}\n\nconst getUnvisitedNeighbors = (grid,current)=> {\n    var neighbors = [];\n    const {col, row} = current;\n    if (row > 0){\n        // console.log(grid[row - 1][col])    \n        neighbors.push(grid[row - 1][col]);\n    } \n    if (row < grid.length - 1){\n        // console.log(grid[row + 1][col])\n        neighbors.push(grid[row + 1][col]);\n    } \n    if (col > 0){\n        // console.log(grid[row][col - 1])\n        neighbors.push(grid[row][col - 1]);\n    } \n    if (col < grid[0].length - 1){\n        // console.log(grid[row][col + 1])\n        neighbors.push(grid[row][col + 1]);\n    }\n    // console.log(\"BEFORE FILTER\",neighbors)\n    // return neighbors.filter(neighbor => !neighbor.isVisited);\n    return neighbors;\n  }\n\nconst Astar = (startNode,endNode,grid)=>{\n    let openSet = [] // unvisited nodes (will contain nodes which we have to visit)\n    let closedSet = [] //visited nodes\n    let path = [] // will contain shortst path\n    let visitedNodes = []\n\n    openSet.push(startNode)\n    while(openSet.length>0){\n        let leastIndex = 0; \n        for(let i=0;i<openSet.length;i++){\n            if(openSet[i].f < openSet[leastIndex].f){\n                leastIndex = i;\n            }\n        }\n\n        let current = openSet[leastIndex];\n        visitedNodes.push(current)\n\n        if(current === endNode){\n            console.log(\"PATH FOUND\")\n            let temp = current;\n            path.push(temp);\n            while(temp.previousNode){\n                path.push(temp.previousNode)\n                temp = temp.previousNode;\n            }\n            // console.log(path)\n            return {path,visitedNodes};\n        }\n\n        openSet = openSet.filter((elt) => elt!==current);\n        closedSet.push(current)\n        let neighbors = getUnvisitedNeighbors(grid,current);\n        // console.log(\"NEIGHBOUTS\",neighbors)\n        for(let i=0;i<neighbors.length;i++){\n            let neighbor = neighbors[i];\n            if(!closedSet.includes(neighbor) && !neighbor.isWall){\n                let tempG = current.g + 1;\n                let newPath = false;\n                if(openSet.includes(neighbor)){\n                    if(tempG < neighbor.g){\n                        neighbor.g = tempG;\n                        newPath = true;\n                    }\n                }else{\n                    neighbor.g = tempG;\n                    newPath=true;\n                    openSet.push(neighbor);\n                }\n\n                if(newPath){\n                    neighbor.h = heru(neighbor,endNode);\n                    neighbor.f = neighbor.g + neighbor.f;\n                    neighbor.previousNode = current;\n                }\n            }\n        }\n    }\n    return {path,visitedNodes}\n}\n\n\n\n  export default Astar;"],"mappings":"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"},"metadata":{},"sourceType":"module"}