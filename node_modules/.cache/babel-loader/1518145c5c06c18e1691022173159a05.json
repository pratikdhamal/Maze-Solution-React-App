{"ast":null,"code":"// Returns all nodes in the order in which they were visited.\n// Make nodes point back to their previous node so that we can compute the shortest path\n// by backtracking from the finish node.\nexport function dfs(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  const nextNodesStack = [];\n  nextNodesStack.push(startNode);\n\n  while (nextNodesStack.length) {\n    const currentNode = nextNodesStack.pop();\n\n    if (currentNode === finishNode) {\n      return visitedNodesInOrder;\n    }\n\n    if (!currentNode.isWall && (currentNode.isStart || !currentNode.isVisited)) {\n      currentNode.isVisited = true;\n      visitedNodesInOrder.push(currentNode);\n      const {\n        col,\n        row\n      } = currentNode;\n      let nextNode;\n\n      if (row > 0) {\n        nextNode = grid[row - 1][col];\n\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n\n      if (row < grid.length - 1) {\n        nextNode = grid[row + 1][col];\n\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n\n      if (col > 0) {\n        nextNode = grid[row][col - 1];\n\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n\n      if (col < grid[0].length - 1) {\n        nextNode = grid[row][col + 1];\n\n        if (!nextNode.isVisited) {\n          nextNode.previousNode = currentNode;\n          nextNodesStack.push(nextNode);\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["dfs","grid","startNode","finishNode","visitedNodesInOrder","nextNodesStack","push","length","currentNode","pop","isWall","isStart","isVisited","col","row","nextNode","previousNode"],"sources":["C:/Users/91842/Desktop/TY13 DAA Maze Solution React App/src/Algorithms/dfs.js"],"sourcesContent":["// Returns all nodes in the order in which they were visited.\r\n// Make nodes point back to their previous node so that we can compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function dfs(grid, startNode, finishNode) {\r\n    const visitedNodesInOrder = [];\r\n    const nextNodesStack = [];\r\n    nextNodesStack.push(startNode);\r\n    while (nextNodesStack.length) {\r\n      const currentNode = nextNodesStack.pop();\r\n  \r\n      if (currentNode === finishNode) {\r\n        return visitedNodesInOrder;\r\n      }\r\n  \r\n      if (\r\n        !currentNode.isWall &&\r\n        (currentNode.isStart || !currentNode.isVisited)\r\n      ) {\r\n        currentNode.isVisited = true;\r\n        visitedNodesInOrder.push(currentNode);\r\n  \r\n        const {col, row} = currentNode;\r\n        let nextNode;\r\n        if (row > 0) {\r\n          nextNode = grid[row - 1][col];\r\n          if (!nextNode.isVisited) {\r\n            nextNode.previousNode = currentNode;\r\n            nextNodesStack.push(nextNode);\r\n          }\r\n        }\r\n        if (row < grid.length - 1) {\r\n          nextNode = grid[row + 1][col];\r\n          if (!nextNode.isVisited) {\r\n            nextNode.previousNode = currentNode;\r\n            nextNodesStack.push(nextNode);\r\n          }\r\n        }\r\n        if (col > 0) {\r\n          nextNode = grid[row][col - 1];\r\n          if (!nextNode.isVisited) {\r\n            nextNode.previousNode = currentNode;\r\n            nextNodesStack.push(nextNode);\r\n          }\r\n        }\r\n        if (col < grid[0].length - 1) {\r\n          nextNode = grid[row][col + 1];\r\n          if (!nextNode.isVisited) {\r\n            nextNode.previousNode = currentNode;\r\n            nextNodesStack.push(nextNode);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  "],"mappings":"AAAA;AACA;AACA;AAEA,OAAO,SAASA,GAAT,CAAaC,IAAb,EAAmBC,SAAnB,EAA8BC,UAA9B,EAA0C;EAC7C,MAAMC,mBAAmB,GAAG,EAA5B;EACA,MAAMC,cAAc,GAAG,EAAvB;EACAA,cAAc,CAACC,IAAf,CAAoBJ,SAApB;;EACA,OAAOG,cAAc,CAACE,MAAtB,EAA8B;IAC5B,MAAMC,WAAW,GAAGH,cAAc,CAACI,GAAf,EAApB;;IAEA,IAAID,WAAW,KAAKL,UAApB,EAAgC;MAC9B,OAAOC,mBAAP;IACD;;IAED,IACE,CAACI,WAAW,CAACE,MAAb,KACCF,WAAW,CAACG,OAAZ,IAAuB,CAACH,WAAW,CAACI,SADrC,CADF,EAGE;MACAJ,WAAW,CAACI,SAAZ,GAAwB,IAAxB;MACAR,mBAAmB,CAACE,IAApB,CAAyBE,WAAzB;MAEA,MAAM;QAACK,GAAD;QAAMC;MAAN,IAAaN,WAAnB;MACA,IAAIO,QAAJ;;MACA,IAAID,GAAG,GAAG,CAAV,EAAa;QACXC,QAAQ,GAAGd,IAAI,CAACa,GAAG,GAAG,CAAP,CAAJ,CAAcD,GAAd,CAAX;;QACA,IAAI,CAACE,QAAQ,CAACH,SAAd,EAAyB;UACvBG,QAAQ,CAACC,YAAT,GAAwBR,WAAxB;UACAH,cAAc,CAACC,IAAf,CAAoBS,QAApB;QACD;MACF;;MACD,IAAID,GAAG,GAAGb,IAAI,CAACM,MAAL,GAAc,CAAxB,EAA2B;QACzBQ,QAAQ,GAAGd,IAAI,CAACa,GAAG,GAAG,CAAP,CAAJ,CAAcD,GAAd,CAAX;;QACA,IAAI,CAACE,QAAQ,CAACH,SAAd,EAAyB;UACvBG,QAAQ,CAACC,YAAT,GAAwBR,WAAxB;UACAH,cAAc,CAACC,IAAf,CAAoBS,QAApB;QACD;MACF;;MACD,IAAIF,GAAG,GAAG,CAAV,EAAa;QACXE,QAAQ,GAAGd,IAAI,CAACa,GAAD,CAAJ,CAAUD,GAAG,GAAG,CAAhB,CAAX;;QACA,IAAI,CAACE,QAAQ,CAACH,SAAd,EAAyB;UACvBG,QAAQ,CAACC,YAAT,GAAwBR,WAAxB;UACAH,cAAc,CAACC,IAAf,CAAoBS,QAApB;QACD;MACF;;MACD,IAAIF,GAAG,GAAGZ,IAAI,CAAC,CAAD,CAAJ,CAAQM,MAAR,GAAiB,CAA3B,EAA8B;QAC5BQ,QAAQ,GAAGd,IAAI,CAACa,GAAD,CAAJ,CAAUD,GAAG,GAAG,CAAhB,CAAX;;QACA,IAAI,CAACE,QAAQ,CAACH,SAAd,EAAyB;UACvBG,QAAQ,CAACC,YAAT,GAAwBR,WAAxB;UACAH,cAAc,CAACC,IAAf,CAAoBS,QAApB;QACD;MACF;IACF;EACF;AACF"},"metadata":{},"sourceType":"module"}