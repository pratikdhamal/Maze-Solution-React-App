[{"C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\index.js":"1","C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\App.js":"2","C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\Redux\\store.js":"3","C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\Components\\MazeSolution.jsx":"4","C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\Redux\\rootReducer.js":"5","C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\Redux\\slice.js":"6","C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\Components\\Node.jsx":"7","C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\Algorithms\\bfs.js":"8","C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\Algorithms\\dfs.js":"9","C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\Algorithms\\dijkstra.js":"10"},{"size":256,"mtime":1654581379000,"results":"11","hashOfConfig":"12"},{"size":292,"mtime":1669564476850,"results":"13","hashOfConfig":"12"},{"size":160,"mtime":1654581379000,"results":"14","hashOfConfig":"12"},{"size":6560,"mtime":1669613335047,"results":"15","hashOfConfig":"12"},{"size":170,"mtime":1654581379000,"results":"16","hashOfConfig":"12"},{"size":1179,"mtime":1654581379000,"results":"17","hashOfConfig":"12"},{"size":1280,"mtime":1654581379000,"results":"18","hashOfConfig":"12"},{"size":1722,"mtime":1669570478837,"results":"19","hashOfConfig":"12"},{"size":1745,"mtime":1669569609388,"results":"20","hashOfConfig":"12"},{"size":2485,"mtime":1669613250534,"results":"21","hashOfConfig":"12"},{"filePath":"22","messages":"23","suppressedMessages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"qfdwyl",{"filePath":"25","messages":"26","suppressedMessages":"27","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"28","messages":"29","suppressedMessages":"30","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"31","messages":"32","suppressedMessages":"33","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34"},{"filePath":"35","messages":"36","suppressedMessages":"37","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"38","messages":"39","suppressedMessages":"40","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"41","messages":"42","suppressedMessages":"43","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"44","messages":"45","suppressedMessages":"46","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"47","messages":"48","suppressedMessages":"49","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"50","messages":"51","suppressedMessages":"52","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\index.js",[],[],"C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\App.js",[],[],"C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\Redux\\store.js",[],[],"C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\Components\\MazeSolution.jsx",["53"],["54"],"import React, { useState, useEffect } from \"react\";\nimport Node from \"./Node\";\nimport { dijkstra, getNodesInShortestPathOrder } from \"../Algorithms/dijkstra\";\nimport { bfs, visitedNodesInOrder} from \"../Algorithms/bfs\";\nimport { dfs} from \"../Algorithms/dfs\";\nimport { selectData, setWalls } from \"../Redux/slice\";\nimport { useSelector, useDispatch } from \"react-redux\";\nconst MazeSolution = () => {\n  const dispatch = useDispatch();\n  const { data } = useSelector(selectData);\n  const [grid, setGrid] = useState([]);\n\n  useEffect(() => {\n    const matrix = formGrid();\n    setGrid(matrix);\n    // eslint-disable-next-line\n  }, []);\n\n  const START_NODE_ROW = data?.startIndex?.row || 10;\n  const START_NODE_COL = data?.startIndex?.col || 15;\n  const FINISH_NODE_ROW = data?.endIndex?.row || 15;\n  const FINISH_NODE_COL = data?.endIndex?.col || 35;\n\n  const createNode = (row, col) => {\n    return {\n      row,\n      col,\n      isStart: row === START_NODE_ROW && col === START_NODE_COL,\n      isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\n      distance: Infinity,\n      isVisited: false,\n      isWall: false,\n      previousNode: null,\n      g: 0,\n      f: 0,\n      h: 0,\n    };\n  };\n\n  const formGrid = () => {\n    const grid = [];\n    for (let row = 0; row < 20; row++) {\n      const currentRow = [];\n      for (let col = 0; col < 50; col++) {\n        currentRow.push(createNode(row, col));\n      }\n      grid.push(currentRow);\n    }\n    return grid;\n  };\n\n  const animateShortestPath = (nodesInShortestPathOrder) => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        document.getElementById(`node-${node.row}-${node.col}`).className =\n          \"node node-shortest-path\";\n      }, 50 * i);\n    }\n  };\n\n  const animateDijkstra = (visitedNodesInOrder, nodesInShortestPathOrder) => {\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        // const startElement = document.getElementsByClassName('node-start');\n        // const endElement = document.getElementsByClassName('node-finish');\n        // console.log(document.getElementById(`node-${node.row}-${node.col}`).classList)\n        document\n          .getElementById(`node-${node.row}-${node.col}`)\n          .classList.add(\"node-visited\");\n        // startElement.classList.add('node-start')\n        // endElement.classList.add('node-finish')\n      }, 10 * i);\n    }\n  };\n\n  const markWalls = (grid) => {\n    const wallArray = data.wallArr;\n    for (let row = 0; row < 20; row++) {\n      for (let col = 0; col < 50; col++) {\n        for (var i = 0; i < wallArray.length; i++) {\n          if (\n            grid[row][col].row === wallArray[i].row &&\n            grid[row][col].col === wallArray[i].col\n          ) {\n            grid[row][col].isWall = true;\n          }\n        }\n      }\n    }\n    return grid;\n  };\n\n  // const setRandomWalls = (grid)=>{\n  //   for (let row = 0; row < 10; row++) {\n  //     for (let col = 0; col < 20; col++) {\n  //         let randomRow = Math.floor(Math.random() * 19);\n  //         let randomCol = Math.floor(Math.random() * 48);\n  //         grid[randomRow][randomCol].isWall = true;\n  //     }\n  //   }\n  //   return grid;\n  // }\n\n  \n  const visualizeDijkstra = () => {\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const newGrid = markWalls(grid);\n    const visitedNodesInOrder = dijkstra(newGrid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  };\n\n  const visualizeBfs = () => {\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const newGrid = markWalls(grid);\n    const visitedNodesInOrder = bfs(newGrid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  };\n\n\n  const visualizeDfs = () => {\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    const newGrid = markWalls(grid);\n    const visitedNodesInOrder = dfs(newGrid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  };\n\n  return (\n    <>\n      <div className=\"fcontainer\">\n        <div>\n          {grid.map((row) => {\n            return (\n              <div>\n                {row.map((node) => {\n                  var { row, col, isWall, isStart, isFinish } = node;\n                  // const wall = Math.round(Math.random())\n                  // if(wall==1){\n                  //   isWall=true;\n                  // }\n                  return (\n                    <Node props={{ row, col, isStart, isWall, isFinish }} />\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </div>\n      <div className=\"container\">\n        <div className=\"node-container\">\n          <div className=\"flex-inner\">\n            <span className=\"index-node node-start\"></span>{\" \"}\n            <span className=\"ml\">Start Node</span>\n          </div>\n          <div className=\"flex-inner\">\n            <span className=\"index-node node-finish\"></span>{\" \"}\n            <span className=\"ml\">End Node</span>\n          </div>\n          <div className=\"flex-inner\">\n            <span className=\"index-node node-wall\"></span> <span className=\"ml\">Wall</span>\n          </div>\n        </div>\n        <div className=\"container\">\n          <button className=\"button\" onClick={() => dispatch(setWalls())}>\n            Set Walls\n          </button>\n          <button className=\"button\" onClick={() => visualizeDijkstra()}>\n            Visualize Dijkstra's Algorithm\n          </button>\n          <button className=\"button\" onClick={() => visualizeBfs()}>\n            Visualize BFS Algorithm\n          </button>\n          <button className=\"button\" onClick={() => visualizeDfs()}>\n            Visualize DFS Algorithm\n          </button>\n        </div>\n      </div>\n    </>\n  );\n};\n\nexport default MazeSolution;\n","C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\Redux\\rootReducer.js",[],[],"C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\Redux\\slice.js",[],[],"C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\Components\\Node.jsx",[],[],"C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\Algorithms\\bfs.js",[],[],"C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\Algorithms\\dfs.js",[],[],"C:\\Users\\91842\\Desktop\\TY13 DAA Maze Solution React App\\src\\Algorithms\\dijkstra.js",[],[],{"ruleId":"55","severity":1,"message":"56","line":4,"column":15,"nodeType":"57","messageId":"58","endLine":4,"endColumn":34},{"ruleId":"59","severity":1,"message":"60","line":17,"column":6,"nodeType":"61","endLine":17,"endColumn":8,"suggestions":"62","suppressions":"63"},"no-unused-vars","'visitedNodesInOrder' is defined but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'formGrid'. Either include it or remove the dependency array.","ArrayExpression",["64"],["65"],{"desc":"66","fix":"67"},{"kind":"68","justification":"69"},"Update the dependencies array to be: [formGrid]",{"range":"70","text":"71"},"directive","",[628,630],"[formGrid]"]